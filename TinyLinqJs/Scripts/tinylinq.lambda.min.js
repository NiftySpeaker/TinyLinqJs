var tinylinq=tinylinq||{};(function(){function n(n){throw new Error(n);}var t=function(n){return n.trim?n.trim():n.replace(/^\s+|\s+$/g,"")},u=function(n,t){for(var i=0,r=n.length;i<r;i++)t(n[i])},i=null,r=null;return tinylinq.Func=function(f){var h,o,e,l,a,c,s;if(f==i)return r;f||f==0||n(strArgumentNullException+"lambdaAsString");typeof f!="string"&&n(strTypeLoadException+"lambdaAsString is not a string");h=f.split("=>");h.length<2&&n("FormatException: No goes-to-sign (=>) found in lambda string");o=t(h[0]);e=[];o.substr(0,1)=="("?(l=o.indexOf(")"),l<0&&n("FormatException: No closing bracket was provided for lambda arguments"),l!=o.length-1&&n("FormatException: Closing bracket must be the last character in lambda arguments section"),o=t(o.substr(1,o.length-2)),e=o.split(","),u(e,function(n){n=t(n)})):(o.indexOf(",")>-1&&n("FormatException: For multiple parameters in a lambda expression, use brackets"),e.push(o));a=h[1].indexOf("return ")>-1;c=a?h[1]:"return ("+h[1]+");";switch(e.length){case 1:s=new Function(e[0],c);break;case 2:s=new Function(e[0],e[1],c);break;case 3:s=new Function(e[0],e[1],e[2],c);break;case 4:s=new Function(e[0],e[1],e[2],e[3],c);break;case 5:s=new Function(e[0],e[1],e[2],e[3],e[4],c);break;default:n("ArgumentOutOfRangeException: Unsupported number of arguments in lambda expresson")}return i=f,r=s,s},tinylinq.FuncOf=function(t,i,r,u,f,e){var o=[];return t&&o.push({type:t,validator:tinylinq.typeEvaluators[t]}),t&&i&&o.push({type:i,validator:tinylinq.typeValidators[i]}),i&&r&&o.push({type:r,validator:tinylinq.typeValidators[r]}),r&&u&&o.push({type:u,validator:tinylinq.typeValidators[u]}),u&&f&&o.push({type:f,validator:tinylinq.typeValidators[f]}),f&&e&&o.push({type:e,validator:tinylinq.typeValidators[e]}),function(t){var i=tinylinq.Func(t);return function(t,r,u,f,e){for(var c=[t,r,u,f,e],h,s=0;s<o.length-1;s++)o[s].validator(c[s])||n("InvalidCastException: Argument "+(s+1)+" is of type TYPE, but should be of type ".replace(/TYPE/g,typeof c[s])+o[s].type);return c[s]&&n("ArgumentException: Not enough types in FuncOf specified for parameter and result types"),h=i(t,r,u,f,e),o[o.length-1].validator(h)||n("InvalidCastException: The result is of type "+typeof h+", but should be of type "+o[s].type+"!"),h}}},tinylinq.typeValidators||(tinylinq.typeValidators={string:function(n){return typeof n=="string"},int:function(n){return typeof n=="number"&&parseInt(n)==parseFloat(n)},float:function(n){return typeof n=="number"},object:function(n){return typeof n=="object"&&!Array.isArray(n)},array:function(n){return Array.isArray(n)},"function":function(n){return typeof n=="function"},bool:function(n){return typeof n=="boolean"}}),tinylinq})();
//# sourceMappingURL=tinylinq.lambda.min.js.map
